/*
 * #%L
 * Bitrepository Integrity Service
 * %%
 * Copyright (C) 2010 - 2012 The State and University Library, The Royal Library and The State Archives, Denmark
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 2.1 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 *
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-2.1.html>.
 * #L%
 */
package org.bitrepository.integrityservice.reports;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.TreeMap;

public class BasicIntegrityReporter implements IntegrityReporter {

    private final String collectionID;
    private final String workflowType;
    private static final String FS_DATE_FORMAT = "yyyyMMdd-HHmmss";
    private static final String REPORT_DATE_FORMAT = "yyyy/MM/dd HH:mm:ss";
    private Long deletedFilesCount = 0L;
    // TreeMaps ensures alphabetical sorting.
    private final Map<String, Long> missingFiles = new TreeMap<>();
    private final Map<String, Long> checksumIssues = new TreeMap<>();
    private final Map<String, Long> missingChecksums = new TreeMap<>();
    private final Map<String, Long> obsoleteChecksums = new TreeMap<>();
    private final IntegrityReportWriter writer;
    private final File reportDir;

    public BasicIntegrityReporter(String collectionID, String workflowType, File reportsDir) {
        this.collectionID = collectionID;
        this.workflowType = workflowType;
        // Date of the report, use for identification and for placing it in time.
        Date reportDate = new Date();
        DateFormat formatter = new SimpleDateFormat(FS_DATE_FORMAT, Locale.ROOT);
        File collectionReportsDir = new File(reportsDir, collectionID);
        if (!collectionReportsDir.isDirectory()) {
            collectionReportsDir.mkdir();
        }
        reportDir = new File(collectionReportsDir, formatter.format(reportDate));
        reportDir.mkdir();
        writer = new IntegrityReportWriter(reportDir);
    }

    @Override
    public boolean hasIntegrityIssues() {
        return !(
                missingFiles.isEmpty() &&
                        checksumIssues.isEmpty() &&
                        missingChecksums.isEmpty() &&
                        obsoleteChecksums.isEmpty()
        );
    }

    @Override
    public boolean hasReport() {
        String reportPath = writer.getReportFilePath();
        File report = new File(reportPath);
        return report.exists();
    }

    @Override
    public File getReportDir() {
        return reportDir;
    }

    @Override
    public File getReport() throws FileNotFoundException {
        String reportPath = writer.getReportFilePath();
        File report = new File(reportPath);
        if (report.exists()) {
            return report;
        } else {
            throw new FileNotFoundException("The report file can't be found on path: " + reportPath);
        }
    }

    @Override
    public void generateReport() throws IOException {
        DateFormat formatter = new SimpleDateFormat(REPORT_DATE_FORMAT, Locale.ROOT);
        String generatedDate = formatter.format(new Date());
        String reportHead = "######## " + "Integrity report generated by " + workflowType
                + " for collection: " + collectionID + " on " + generatedDate + " ########";
        writer.writeReport(reportHead);
        writer.close();
    }

    private String generateSummary() {
        StringBuilder report = new StringBuilder();
        if (deletedFilesCount != 0L) {
            report.append("Detected ").append(deletedFilesCount).append(" files as removed from the collection.");
        }
        for (String pillar : missingFiles.keySet()) {
            if (missingFiles.get(pillar) != 0) {
                report.append("\n").append(pillar).append(" is missing ").append(missingFiles.get(pillar)).append(" file");
                if (missingFiles.get(pillar) > 1) report.append("s");
                report.append(".");
            }
        }

        for (String pillar : checksumIssues.keySet()) {
            if (checksumIssues.get(pillar) != 0) {
                report.append("\n").append(pillar).append(" has ").append(checksumIssues.get(pillar)).append(" potentially corrupt file");
                if (checksumIssues.get(pillar) > 1) report.append("s");
                report.append(".");
            }
        }

        for (String pillar : missingChecksums.keySet()) {
            if (missingChecksums.get(pillar) != 0) {
                report.append("\n").append(pillar).append(" is missing ").append(missingChecksums.get(pillar)).append(" checksum");
                if (missingChecksums.get(pillar) > 1) report.append("s");
                report.append(".");
            }
        }

        for (String pillar : obsoleteChecksums.keySet()) {
            if (obsoleteChecksums.get(pillar) != 0) {
                report.append("\n").append(pillar).append(" has ").append(obsoleteChecksums.get(pillar)).append(" obsolete checksum");
                if (obsoleteChecksums.get(pillar) > 1) report.append("s");
                report.append(".");
            }
        }
        if (report.toString().isEmpty()) {
            return "No integrity issues found";
        } else {
            return report.toString();
        }
    }

    @Override
    public String generateSummaryOfReport() {
        if (!hasIntegrityIssues()) {
            return "No integrity issues found";
        } else {
            return "The following integrity issues were found:" + generateSummary();
        }
    }

    @Override
    public String getCollectionID() {
        return collectionID;
    }

    @Override
    public void reportDeletedFile(String pillarID, String fileID) throws IOException {
        deletedFilesCount++;
        writer.writeDeletedFile(pillarID, fileID);

    }

    @Override
    public void reportMissingFile(String fileID, String pillarID) throws IOException {
        if (missingFiles.containsKey(pillarID)) {
            missingFiles.put(pillarID, (missingFiles.get(pillarID) + 1));
        } else {
            missingFiles.put(pillarID, 1L);
        }
        writer.writeMissingFile(pillarID, fileID);
    }

    @Override
    public void reportChecksumIssue(String fileID, String pillarID) throws IOException {
        if (checksumIssues.containsKey(pillarID)) {
            checksumIssues.put(pillarID, (checksumIssues.get(pillarID) + 1));
        } else {
            checksumIssues.put(pillarID, 1L);
        }
        writer.writeChecksumIssue(pillarID, fileID);
    }

    @Override
    public void reportMissingChecksum(String fileID, String pillarID) throws IOException {
        if (missingChecksums.containsKey(pillarID)) {
            missingChecksums.put(pillarID, (missingChecksums.get(pillarID) + 1));
        } else {
            missingChecksums.put(pillarID, 1L);
        }
        writer.writeMissingChecksum(pillarID, fileID);
    }

    @Override
    public void reportObsoleteChecksum(String fileID, String pillarID) throws IOException {
        if (obsoleteChecksums.containsKey(pillarID)) {
            obsoleteChecksums.put(pillarID, (obsoleteChecksums.get(pillarID) + 1));
        } else {
            obsoleteChecksums.put(pillarID, 1L);
        }
        writer.writeObsoleteChecksum(pillarID, fileID);
    }

}
